// Slack Client (discord.gg/slackclient)

package cc.slack.features.modules.impl.exploit;

import cc.slack.events.impl.player.MoveEvent;
import cc.slack.features.modules.api.Category;
import cc.slack.features.modules.api.Module;
import cc.slack.features.modules.api.ModuleInfo;
import cc.slack.features.modules.api.settings.impl.ModeValue;
import cc.slack.features.modules.api.settings.impl.NumberValue;
import io.github.nevalackin.radbus.Listen;

@ModuleInfo(
        name = "Phase",
        category = Category.EXPLOIT
)
public class Phase extends Module {

    private final ModeValue<String> mode = new ModeValue<>(new String[]{"Clip"});
    private final NumberValue<Double> offset = new NumberValue<>("Offset", 1D, 0.1D, 8D, 0.1D);

    boolean insideBlock;

    public Phase() {
        super();
        addSettings(mode, offset);
    }

    @Override
    public void onEnable() {
        insideBlock = false;
    }

    @SuppressWarnings("unused")
    @Listen
    public void onMove(MoveEvent Event) {
        switch (mode.getValue().toLowerCase()) {
            case "clip":
            double yaw = Math.toRadians(mc.thePlayer.rotationYaw);
            if (mc.thePlayer.isCollidedHorizontally) {
                insideBlock = true;
                mc.thePlayer.setPosition(
                        mc.thePlayer.posX + -Math.sin(yaw) * 0.005,
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ + Math.cos(yaw) * 0.005);
            } else if (insideBlock) {
                mc.thePlayer.setPosition(
                        mc.thePlayer.posX + -Math.sin(yaw) * offset.getValue(),
                        mc.thePlayer.posY,
                        mc.thePlayer.posZ + Math.cos(yaw) * offset.getValue());
                insideBlock = false;
            }
            break;
            case "":
                break;
        }
    }

    @Override
    public String getMode() { return mode.getValue().toString(); }

}
